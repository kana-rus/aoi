use std::{future::Future, pin::Pin};
use crate::result::HandleResult;
use aoi_components::request::{
    buffer::Buffer,
    range::{RangeMap, HeaderRangeMap, RangeList},
};

/// aoi's internal handler type
pub(crate) type Handler = Box<
    dyn Fn(Buffer, RangeList, RangeMap, HeaderRangeMap, Option<String>)
        -> Pin<Box<dyn Future<Output=HandleResult> + Send >>
    + Send + Sync
>;

/*
    Internally, aoi's "handler"s areï¼š
    ```
    async fn handler(
        buffer:  Buffer,
        params:  RangeList,
        queries: RangeMap,
        headers: HeaderRangeMap,
        body:    Option<String>,
    ) -> Response {
        /* if user_defined_handler requires:
            let body = </*a concrete type*/ as JSON>::de(
                s._else(/* */)
            )?;
        */
        let mut request = Request { // <-- should be a wrapper type of aoi_components::Request
            buffer, 
            params, 
            queries,
            headers,
            // all fields are private
        };
        request = before_middleware_1(request, body);
        // ...
        request = before_middleware_final(request, body);
        let mut response = match user_defined_handler(request /*, body */)
        {
            Ok(res)  => res,
            Err(res) => res,
        };
        response = after_middleware_1(response);
        // ...
        response = after_middleware_final(response);
        response
    }
    ```


    ( Such middleware-integrated `handler`s are generated by `#[server]` macro )
    Here `#[server]` inserts

    ```
    let param_1 = request.params./* */;
    // ...
    ```
    
    at the beginning of user_defined_handler's process
    so that user can handle path params by their names.
*/